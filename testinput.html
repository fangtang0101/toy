<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <canvas id="canvas" width="256" height="256"></canvas>

  <input type="file" onchange="previewHandle(this,1)" />加密</input>
  <input type="file" onchange="previewHandle(this,0)" />解密</input>
  <img id="preview-img" />
</body>

</html>

<script>

  function previewHandle(fileDOM, type) {
    var file = fileDOM.files[0], // 获取文件
      imageType = /^image\//,
      reader = '';

    // 文件是否为图片
    if (!imageType.test(file.type)) {
      alert("请选择图片！");
      return;
    }
    // 判断是否支持FileReader    
    if (window.FileReader) {
      reader = new FileReader();
    }
    // IE9及以下不支持FileReader
    else {
      alert("您的浏览器不支持图片预览功能，如需该功能请升级您的浏览器！");
      return;
    }
    // 读取完成    
    reader.onload = function (event) {
      // 获取图片DOM
      // var img = document.getElementById("preview-img");
      // // 图片路径设置为读取的图片    
      // img.src = event.target.result;
      console.log('url ...', event.target.result)
      if (type === 1) {
        console.log('加密 ...')
        encipherPic(event.target.result)
      } else {
        console.log('解密 ...')
        decryptPic(event.target.result)
      }
      // 加密
      // 
      // 解密

    };
    reader.readAsDataURL(file);
  }

  // 解密图片
  // decryptPic()
  // 加密图片
  // encipherPic()
  // demoCanvas()
  // 主要是为了 测试 canvas 在写入字体和颜色 之后 的图片获取
  function demoCanvas() {
    // 1. 在填入 颜色的时候 ，必须配合 fillRect 这个使用 否则不生效 fillStyle 与 fillRect 配套使用，（会盖在文字上面），如果想使用背景色，请使用 其他
    // 2. 填入文字可以单独使用，直接填写即可
    // 3. 如果仅仅单独使用 文字,那么 getImageData 的方法，RGBA 的值只会有 两种，前面三个都是 0（也就是背景色为0，白色），只有最后A的值是 255（有字体的颜色，黑色） 和 0（没有字体） 的区别，所以只有这样比较适合做加密

    //单独文字
    // var ctx = document.getElementById('canvas').getContext('2d');
    // var textData;
    // ctx.font = '30px Microsoft Yahei';
    // ctx.fillText('广告位招租u', 0, 30);
    // textData = ctx.getImageData(0, 0, 100, 30).data;
    // console.log('textData', textData);

    // 文字 + 颜色
    // var ctx = document.getElementById('canvas').getContext('2d');
    // var textData;
    // ctx.font = '30px Microsoft Yahei';
    // ctx.fillText('广告位招租u', 0, 30);
    // ctx.fillStyle = "#988790";
    // ctx.fillRect(0, 0, 50, 50);
    // textData = ctx.getImageData(0, 0, 100, 30).data;
    // console.log('textData', textData);

    // 文字 + 背景色 通过 透明度来 控制背景，如果有颜色，那么 textData 的第四项 就是 0-256
    var ctx = document.getElementById('canvas').getContext('2d');
    var textData;
    ctx.font = '30px Microsoft Yahei';
    ctx.fillText('广告位招租u', 0, 30);
    ctx.fillStyle = "#988790";
    ctx.globalAlpha = 0.1
    ctx.fillRect(0, 0, 50, 50);
    textData = ctx.getImageData(0, 0, 100, 30).data;
    console.log('textData', textData);
  }
  // 加密
  function encipherPic(url) {
    var dom = document.getElementById('canvas')
    var ctx = document.getElementById('canvas').getContext('2d');

    var textData;
    // 这些canvas API，好久没用，需要查API文档了T_T
    ctx.font = '30px Microsoft Yahei';
    ctx.fillText('广告位招租u', 0, 30);
    textData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height).data;


    var img = new Image();
    var originalData;
    img.onload = function (e) {
      console.log('图片信息 ...', e)
      console.log('图片信息 ...111', img.width, img.height)
      // dom.style.width = `${img.width}px`
      // dom.style.height = `${img.height}px`
      console.log('333', ctx.canvas.width, ctx.canvas.height)
      ctx.drawImage(img, 0, 0);
      // 获取指定区域的canvas像素信息
      originalData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height); // 256,256
      // console.log('originalData', originalData);
      // console.log('textData', textData);
      // textData.forEach(v => {
      //   if (v != 0) {
      //     console.log(v)
      //   }
      // })

      // processData(originalData)
      mergeData(textData, 'R');
    };
    // img.src = `http://127.0.0.1:8080/cat.png`;
    img.src = url



    var mergeData = function (newData, color) {
      var oData = originalData.data;
      var bit, offset;  // offset的作用是找到alpha通道值，这里需要大家自己动动脑筋

      switch (color) {
        case 'R':
          bit = 0;
          offset = 3;
          break;
        case 'G':
          bit = 1;
          offset = 2;
          break;
        case 'B':
          bit = 2;
          offset = 1;
          break;
      }
      for (var i = 0; i < oData.length; i++) {
        if (i % 4 == bit) {
          // 只处理目标通道，进入的都是 对应通道的，都是 R 通道，也就是 4 一组，RGBA 中的 R
          // newData[i + offset] === 0 代表 嵌入的防伪的图片 对应的那一组 RGBA 中 的透明度 为 0 ，
          // oData[i] % 2 === 1 原始图片 的对应的同样位置的 透明度 的值（0-255） 为基数
          if (newData[i + offset] === 0 && (oData[i] % 2 === 1)) {
            // 下面的目的的就是：将 加密图形，对应的 A的值为 0，也就是 透明的部分，对应上 原始图相同的位置的透明度的 === 保证其为 偶数（为了解密用-- 也就是偶数的地方 就是 透明的）
            // 没有信息的像素，该通道最低位置0，但不要越界
            if (oData[i] === 255) {
              oData[i]--;
            } else {
              oData[i]++;
            }
          }
          // 有透明度的地方 将对应的原始图形 全部变成 奇数（奇数的地方全是 有东西的）
          else if (newData[i + offset] !== 0 && (oData[i] % 2 === 0)) {
            // // 有信息的像素，该通道最低位置1，可以想想上面的斑点效果是怎么实现的
            if (oData[i] === 255) {
              oData[i]--;
            } else {
              oData[i]++;
            }
          }
        }
      }
      ctx.putImageData(originalData, 0, 0);
    }
  }
  // 解密
  function decryptPic(url) {
    var ctx = document.getElementById('canvas').getContext('2d');
    var img = new Image();
    var originalData;
    img.onload = function (e) {
      console.log('图片信息 ...', e)
      ctx.drawImage(img, 0, 0);
      // 获取指定区域的canvas像素信息
      originalData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height); // 256,256
      // console.log(originalData);
      processData(originalData)
    };
    // img.src = `http://127.0.0.1:8080/xiaolan.png`;
    // img.src = `http://127.0.0.1:8080/test_cat.png`;

    img.src = url;

    var processData = function (originalData) {
      var data = originalData.data;
      for (var i = 0; i < data.length; i++) {
        if (i % 4 === 0) {
          // 第4 位的 A的值
          if (data[i] % 2 == 0) {
            // 偶数是 透明的
            data[i] = 0;
            data[i + 1] = 0
            data[i + 2] = 0
            data[i + 3] = 0
          } else {
            // 奇数是有画面的
            // data[i] = 255;
            data[i] = 0;
            data[i + 1] = 0
            data[i + 2] = 0
            data[i + 3] = 255
            // console.log('奇数')
          }
        }
        // else {
        //   data[i] = 255;
        // }

        // if (i % 4 == 0) {
        //   // 红色分量
        //   if (data[i] % 2 == 0) {
        //     data[i] = 0;
        //   } else {
        //     data[i] = 255;
        //   }
        // } else if (i % 4 == 3) {
        //   // alpha通道不做处理
        //   continue;
        // } else {
        //   // 关闭其他分量，不关闭也不影响答案，甚至更美观 o(^▽^)o
        //   data[i] = 0;
        // }
      }
      // 将结果绘制到画布
      ctx.putImageData(originalData, 0, 0);
    }
  }


</script>